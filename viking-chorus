#!/usr/bin/python
from __future__ import with_statement

import errno
import logging
import os
import subprocess
import sys

log = logging.getLogger('viking-chorus')
log_git = logging.getLogger('viking-chorus.git')
log_qsf = logging.getLogger('viking-chorus.qsf')

def mkdir(*a, **kw):
    try:
        os.mkdir(*a, **kw)
    except OSError, e:
        if e.errno == errno.EEXIST:
            pass
        else:
            raise

def git_rev_parse(ref):
    log_git.debug('Running rev-parse on %r', ref)
    with os.tmpfile() as f:
        with file('/dev/null') as devnull:
            returncode = subprocess.call(
                [
                    'git',
                    'rev-parse',
                    '--revs-only',
                    '--default', ref,
                    ],
                close_fds=True,
                stdin=devnull,
                stdout=f,
                stderr=sys.stderr,
                )
        if returncode != 0:
            raise RuntimeError(
                'git rev-parse failed: %r' % returncode)

        f.seek(0)
        sha = f.readline()
    if not sha:
        # no output -> bad ref
        return None
    if sha[-1] != '\n':
        # partial line -> weird?
        return None
    sha = sha[:-1]
    log_git.debug('rev-parse result: %r', sha)
    return sha

def git_update_ref(ref, new, old=None, reason=None):
    log_git.debug(
        'Running update-ref to set %r from %r to %r with reason %r',
        ref, old, new, reason,
        )
    args = [
        'git',
        'update-ref',
        ]
    if reason is not None:
        args.extend([
                '-m', reason,
                ])
    if new is None:
        args.extend([
                '-d', ref,
                ])
    else:
        args.extend([
                ref,
                new,
                ])
    if old is not None:
        args.extend([
                old,
                ])

    with file('/dev/null') as devnull:
        returncode = subprocess.call(
            args=args,
            close_fds=True,
            stdin=devnull,
            stdout=sys.stderr,
            stderr=sys.stderr,
            )
        if returncode != 0:
            raise RuntimeError('git update-ref failed: %r' % returncode)

def git_diff_tree(
    src,
    dst,
    paths=None,
    detect_renames=None,
    detect_copies=None,
    diff_filter=None,
    ):
    log_git.debug(
        'Running diff-tree %r %r',
        src, dst,
        )
    args = [
        'git',
        'diff-tree',
        '-r',
        '--root',
        '--no-commit-id',
        '--raw',
        '-z',
        ]
    if detect_renames:
        if detect_renames is True:
            args.append('-M')
        else:
            args.append('-M%s' % detect_renames)
    if detect_copies:
        if detect_copies is True:
            args.append('-C')
        else:
            args.append('-C%s' % detect_copies)
    if diff_filter is not None:
        args.append('--diff-filter=%s' % diff_filter)
    args.extend([
        src,
        dst,
        ])
    if paths is not None:
        args.append('--')
        args.extend(paths)

    with file('/dev/null') as devnull:
        p = subprocess.Popen(
            args=args,
            close_fds=True,
            stdin=devnull,
            stdout=subprocess.PIPE,
            stderr=sys.stderr,
            )
        data = ''
        while True:
            more = p.stdout.read(8192)
            data += more

            while data:
                try:
                    nul1 = data.index('\0')
                except ValueError:
                    # status truncated, read more
                    break
                field = data[:nul1]
                if field[0] != ':':
                    raise RuntimeError(
                        'Result must start with colon: %r' % status)
                (src_mode, dst_mode, src_sha1, dst_sha1, status) \
                    = field.split(' ', 4)

                try:
                    end = nul2 = data.index('\0', nul1+1)
                except ValueError:
                    # filename truncated, read more
                    break
                src_path = data[nul1+1:nul2]

                if status[0] in ['C', 'R']:
                    try:
                        end = nul3 = data.index('\0', nul2+1)
                    except ValueError:
                        # filename truncated, read more
                        break
                    dst_path = data[nul2+1:nul3]
                else:
                    dst_path = None

                result = dict(
                    status=status,
                    src=dict(
                        mode=src_mode,
                        sha1=src_sha1,
                        path=src_path,
                        ),
                    dst=dict(
                        mode=dst_mode,
                        sha1=dst_sha1,
                        ),
                    )
                if dst_path is not None:
                    result['dst']['path'] = dst_path
                data = data[end+1:]
                yield result

            if not more:
                break

        if data:
            raise RuntimeError('Trailing data: %r' % data)

        returncode = p.wait()
        if returncode != 0:
            raise RuntimeError(
                'git diff-tree failed: %r' % returncode)


def updated_files(old, new):
    for data in git_diff_tree(
        src=old,
        dst=new,
        detect_renames=9,
        diff_filter='AR',
        ):
        yield data['src']['path']

def spamminess(path):
    log_qsf.debug('Running qsf on %r', path)
    try:
        msg = file(path)
    except IOError, e:
        if e.errno == errno.ENOENT:
            return None
        else:
            raise
    with msg as msg:
        child = subprocess.Popen(
            [
                'qsf',
                '--test',
                '--rating',
                ],
            close_fds=True,
            stdin=msg,
            stdout=subprocess.PIPE,
            stderr=sys.stderr,
            )
        rating = child.stdout.readline()
        if rating == '':
            # message was too big for qsf, it skipped processing
            # assume ham
            log_qsf.debug('Too big to check')
            rating = 0
        else:
            rating = int(rating)
            log_qsf.debug('Spamminess %d%%', rating)
        # ignore any other output, while complaining
        for line in child.stdout:
            log_qsf.warn('qsf extra stdout: %r', line)
        returncode = child.wait()
        if returncode in [0, 1]:
            return rating
        else:
            raise RuntimeError(
                'qsf failed: %r' % returncode)

def __main__(args):
    logging.basicConfig(level=logging.INFO)
    old = git_rev_parse('refs/heads/antispam')
    if old is None:
        raise RuntimeError('Cannot figure out antispam state.')

    new = git_rev_parse('HEAD')
    if new is None:
        raise RuntimeError('Cannot figure out git HEAD.')

    if new == old:
        log.info('Nothing to do.')
        return

    log.info('Spam check %s to %s', old, new)

    for path in updated_files(old, new):
        parent, basename = os.path.split(path)
        if not parent:
            # top level file, can't be maildir
            continue
        # git should just never output trailing slash filenames
        assert basename

        folder, section = os.path.split(parent)
        if not folder:
            # one level from top, can't be maildir
            continue
        if section not in ['cur', 'new']:
            continue

        if (folder == 'Junk'
            or folder.endswith('.spam')):
            continue
        spam_folder = '%s.spam' % folder
        if not os.path.isdir(spam_folder):
            continue

        rating = spamminess(path)
        if rating is None:
            log.debug('Miss %s', path)
            continue
        if rating > 90:
            rounded_rating = int(round(rating/5.0)) * 5
            new_path = os.path.join(
                '%s.%d' % (spam_folder, rounded_rating),
                section,
                basename,
                )
            log.info('Spam %-3d%% %s', rating, path)
            log.debug('Move %s to %s', path, new_path)
            try:
                os.rename(path, new_path)
            except OSError, e:
                if e.errno == errno.ENOENT:
                    # lost a race
                    pass
                else:
                    raise
        else:
            log.info('Ham  %-3d%% %s', rating, path)

    git_update_ref(
        'refs/heads/antispam', new, old,
        reason='Checked spam')

if __name__ == '__main__':
    sys.exit(__main__(sys.argv))
